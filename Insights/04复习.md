# 1.createElement 和 createTextNode 创建虚拟 dom

vite 的 esbuild 会把 jsx 语法解析成 createElement 语法。在引入 React 之后，自动调用 React 上的 createElement 方法创建虚拟 dom，数据结构如下

```ts
interface VirtualDOM {
  type: string;
  props: {
    [prop: string]?: any;
    children: Array<VirtualDOM> | [];
  };
}
```

在处理 children 的时候会考虑传入的 child 的类型，如果是文本节点，那么调用 createTextNode 创建出文本节点的虚拟 DOM，数据结构如下

```ts
interface TextNodeVDOM extends VirtualDOM {
  type: 'TEXT_ELEMENT';
  props: {
    nodeValue: string | number;
    children: [];
  };
}
```

# 2.render

## 2.1 createDOMNode 根据虚拟 dom 节点的类型创建真实 dom 节点

```js
function createDOMNode(type) {
  const dom =
    type === 'TEXT_ELEMENT'
      ? document.createTextNode('')
      : document.createElement(type);
}
```

## 2.2 设置 props，需要考虑三种情况：class（不规范，应该用 className 传入类名），style object，对 children 里面的每个子虚拟节点递归 render，其他属性如 id、nodeValue 等

```js
Reflect.ownKeys(props).forEach((propKey) => {
  switch (propKey) {
    case 'class':
      dom.className = props.class;
      break;
    case 'style':
      const styleObj = props.style;
      Object.keys(styleObj).forEach((styleKey) => {
        dom.style[styleKey] = styleObj[styleKey];
      });
      break;
    case 'children':
      console.log(props);
      const children = props.children;
      children.forEach((child) => {
        render(child, dom);
      });
      break;
    default:
      dom[propKey] = props[propKey];
      break;
  }
});
```

## 2.3 将 dom 挂载到 container 上

# 3.fiber 架构的任务调度

## 3.1 使用 requestIdleCallback 在浏览器空余时间执行任务

```js
let nextWorkOfUnit = null;
function workLoop(deadline) {
  let shouldYield = false;
  while (shouldYield && nextWorkOfUnit) {
    nextWorkOfUnit = performWorkOfUnit(nextWorkOfUnit);
  }
  requestIdleCallback(workLoop);
}
requestIdleCallback(workLoop);
```

## 3.2 程序主入口是 render，在 render 处为 nextWorkOfUnit 赋值使得 requestIdleCallback 内的工作开始执行

```js
render(el, container){
  nextWorkOfUnit = {
    dom: container,
    el: {
      children: [el]
    }
  } //这个时候nextWorkOfUnit不再为空，直接进入while循环
}
```

## 3.3 在执行任务的同时将 dom 树按照前序遍历顺序转化为链表——微任务队列，边执行任务边返回新任务

```js
function performWorkOfUnit(fiber) {
  // 执行任务
  if (!fiber.dom) {
    // 创建dom
    // 挂载到父亲dom
    // 处理props
  }
  // 遍历虚拟DOM树的节点，建立任务与任务的关系，子 -> 兄弟 -> 叔叔
  const children = fiber.props.children;
  let prevChild = null; // 连接兄弟节点的时候有用
  children.forEach((child, index) => {
    let newFiber = {
      type: child.type,
      props: chilld.props,
      child: null,
      parent: fiber,
      sibling,
    };
    if (index === 0) {
      fiber.child = newFiber;
    } else {
      prevChild.sibling = newFiber;
    }
    prevChild = newFiber;
  });
  // 返回新任务
  if (fiber.child) {
    return fiber.child;
  }
  if (fiber.sibling) {
    return fiber.sibling;
  }
  return fiber.parent.sibling;
}
```

链表中每个 fiber 的数据结构继承自 virtual dom

```js
interface Fiber extends VirtualDOM {
  type: string,
  props: {
    [prop: string]?: any;
    children: Array<VirtualDOM> | [];
  },
  child?: null | Fiber,
  parent?: Fiber, // 根容器不存在parent和sibling
  sibling?: null | Fiber,
  dom?: HTMLElement // function component不存在dom
}
```

// v1 创建虚拟节点并渲染成真实 dom

```js
// 创建virtual dom
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map((child) => {
        return /^(string|number)/.test(typeof child)
          ? createTextNode(child)
          : child;
      }),
    },
  };
}
function createTextNode(nodeValue) {
  return {
    type: 'TEXT_ELEMENT',
    props: {
      nodeValue,
      children: [],
    },
  };
}
// 根据类型创建真实dom
function createDOMNode(type) {
  const dom =
    type === 'TEXT_ELEMENT'
      ? document.createTextNode('')
      : document.createElement(type);
  return dom;
}
function render(el, container) {
  // 1.创建node
  const dom = createDOMNode(el.type);
  // 2.处理props
  const props = el.props;
  Reflect.ownKeys(props).forEach((propKey) => {
    switch (propKey) {
      case 'class':
        dom.className = props.class;
        break;
      case 'style':
        const styleObj = props.style;
        Object.keys(styleObj).forEach((styleKey) => {
          dom.style[styleKey] = styleObj[styleKey];
        });
        break;
      case 'children':
        console.log(props);
        const children = props.children;
        children.forEach((child) => {
          render(child, dom);
        });
        break;
      default:
        dom[propKey] = props[propKey];
        break;
    }
  });
  // 3.挂载到contaienr
  container.append(dom);
}
const React = {
  render,
  createElement,
};
export default React;
```

// v2 fiber 架构和任务调度器

```js
// 创建virtual dom
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map((child) => {
        return /^(string|number)/.test(typeof child)
          ? createTextNode(child)
          : child;
      }),
    },
  };
}
function createTextNode(nodeValue) {
  return {
    type: 'TEXT_ELEMENT',
    props: {
      nodeValue,
      children: [],
    },
  };
}
// 根据类型创建真实dom
function createDOMNode(type) {
  const dom =
    type === 'TEXT_ELEMENT'
      ? document.createTextNode('')
      : document.createElement(type);
  return dom;
}
// 主入口
function render(el, container) {
  nextWorkOfUnit = {
    dom: container,
    props: {
      children: [el],
    },
  };
}
let nextWorkOfUnit = null;
function workLoop(deadline) {
  let shouldYield = false;
  while (!shouldYield && nextWorkOfUnit) {
    nextWorkOfUnit = performWorkOfUnit(nextWorkOfUnit);
    shouldYield = deadline.timeRemaining() < 1;
  }
  requestIdleCallback(workLoop);
}
// 执行微任务队列
function performWorkOfUnit(fiber) {
  if (!fiber.dom) {
    // 1.创建node
    fiber.dom = createDOMNode(fiber.type);
    // 2.挂载dom
    fiber.parent.dom.append(fiber.dom);
    // 3.处理props
    updateProps(fiber.dom, fiber.props);
  }
  initChildren(fiber);

  // 返回下一个fiber，注意可能有很多层，可能要向上找很多层parent
  if (fiber.child) {
    return fiber.child;
  }
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling;
    }
    nextFiber = nextFiber.parent;
  }
}
// 处理vdom的props
function updateProps(dom, props) {
  Reflect.ownKeys(props).forEach((propKey) => {
    switch (propKey) {
      case 'class':
        dom.className = props.class;
        break;
      case 'style':
        const styleObj = props.style;
        Object.keys(styleObj).forEach((styleKey) => {
          dom.style[styleKey] = styleObj[styleKey];
        });
        break;
      case 'children':
        console.log(props);
        const children = props.children;
        children.forEach((child) => {
          render(child, dom);
        });
        break;
      default:
        dom[propKey] = props[propKey];
        break;
    }
  });
}
// 将DOM树按照前序遍历的顺序组织成链表
function initChildren(fiber) {
  let prevChild = null;
  fiber.props.children.forEach((child, index) => {
    const newFiber = {
      type: child.type,
      props: child.props,
      child: null,
      parent: fiber,
      sibling: null,
    };
    if (index === 0) {
      fiber.child = newFiber;
    } else {
      prevChild.sibling = newFiber;
    }
    prevChild = newFiber;
  });
}
requestIdleCallback(workLoop);
const React = {
  render,
  createElement,
};
export default React;
```
