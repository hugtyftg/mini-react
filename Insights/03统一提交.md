# 问题

## requestIdleCallback 带来的界面渲染卡顿问题

### 问题理解

在每个空闲时间片内执行任务，创建出来一个节点，如果在没有完全创建完 dom 节点的时候，当前的空闲时间片就用完了、不会再调用 callback，任务的执行被中断了。只有过了一段时间、到了下一次出现空闲时间片的时候，才会再次调用 callback，才能继续渲染其他的 DOM。
这样一来，用户只会看到界面只出现一部分 DOM 而不是完整的 DOM，过了一段时间后才会陆续出现其他 DOM

### 解决方案

这个问题的本质是浏览器内核在执行任务的过程中具有异步性，以一种不可预知的速度执行每一个任务，因此空闲时间的出现以及对应 callback 的调用也是不可预估、时有时无的。

如果在这样的时间内安排视觉呈现的工作，难免会出现断断续续的卡顿渲染，正如 MDN 官方文档对该 api 的注解一样：

<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%A9%BA%E9%97%B2%E5%9B%9E%E8%B0%83">**避免在空闲回调中改变 DOM**。空闲回调执行的时候，当前帧已经结束绘制了，所有布局的更新和计算也已经完成。如果你做的改变影响了布局，你可能会强制停止浏览器并重新计算，而从另一方面来看，这是不必要的。如果你的回调需要改变 DOM，它应该使用 Window.requestAnimationFrame() 来调度它。</a>

因此只需要在这些时间片内进行计算工作，在链表计算处理结束的时候统一 提交渲染即可，一次呈现所有内容优于多次陆续呈现内容。

## DOM 树按照前序遍历顺序生成微任务执行队列（链表）的性能问题

### 问题理解

在当前对于子节点数组的处理过程中，如果目前已经递归访问到很深的树的层级，并且已经没有 child 和 sibling，并且父亲、祖父等也都没有 sibling 了，这个 node 就会一直向上跳转很多层、寻找很多层的 curNode.parent.sibling，这个过程非常慢，会导致卡顿
